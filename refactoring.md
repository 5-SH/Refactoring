# 리팩터링

## 2. 리팩터링 원칙
> ### 2.1 리팩터링은 그 과정에서 겉보기 동작 유지가 중요하다.
> ### 2.2 기능 추가와 리팩터링을 명확하게 구분하라
> ### 2.3 YAGNI (You Aren't Going to Need It)
> ### 2.4 리팩터링과 성능
> - 성능에 신경쓰지 않고 보기 좋게 코딩한다
> - 성능 최적화가 필요하면 프로파일링해서 실행 시간이 긴 코드를 특정한다.
> - 그 부분을 개선한다.

## 3. 코드에서 나는 악취
> ### 3.1 기이한 이름
> ### 3.2 중복 코드
> ### 3.3 긴 함수
> ### 3.4 긴 매개변수 목록
> ### 3.5 전역 데이터
> ### 3.6 가변 데이터
> ### 3.7 뒤엉킨 변경
> ### 3.8 산탄총 수술
> ### 3.9 기능 편애
> ### 3.10 데이터 뭉치
> ### 3.11 기본형 집착
> ### 3.12 반복되는 switch문
> ### 3.13 반복문
> ### 3.14 성의 없는 요소
> ### 3.15 추측성 리반화
> ### 3.16 임시 필드
> ### 3.17 메세지 체인
> ### 3.18 중개자
> ### 3.19 내부자 거래
> ### 3.20 거대한 클래스
> ### 3.21 서로 다른 인터페이스의 대안 클래스들
> ### 3.22 데이터 클래스
> ### 3.23 상속 포기
> ### 3.24 주석

## 6. 기본적인 리팩터링
> ### 6.1 함수 추줄하기
> ### 6.2 함수 인라인하기
> ### 6.3 변수 추출하기
> ### 6.4 변수 인라인하기
> ### 6.5 함수 선언 바꾸기
> ### 6.6 변수 캡슐화하기
> ### 6.7 변수 이름 바꾸기
> ### 6.8 매개변수 객체 만들기
> ### 6.9 여러 함수를 클래스로 묶기
> - 원본 데이터 수정이 있는 경우 사용
> ### 6.10 여러 함수를 변환 함수로 묶기
> - 원본 데이터 수정이 없는 경우 사용
> ### 6.11 단계 쪼개기

## 7. 캡슐화
> ### 7.1 레코드 캡슐화하기
> - 데이터를 쓰는 함수를 만든다.
> - 데이터를 읽는 코드는 독립 함수로 추출한다.
> - 또는 내부 데이터를 복제해서 제공하거나 읽기 전용 프록시를 반환한다.
> ### 7.2 컬렉션 캡슐화하기
> - 원소를 추가/제거하는 함수를 만들고 세터를 제거한다.
> - 게터는 원본 내용을 수정할 수 없도록 읽기 전용 프록시나 복제본을 반환한다.
> ### 7.3 기본형을 객체로 바꾸기
> - 단순한 출력 이상의 기능이 필요해지면 기본형을 객체로 바꾼다.
> ### 7.4 임시 변수를 질의 함수로 바꾸기
> - 클래스에서 수행할 때 효과가 좋다.
> ### 7.5 클래스 추출하기 
> ### 7.6 클래스 인라인하기
> ### 7.7 위임 숨기기
> ### 7.8 중재자 제거하기
> - 디미터 법칙, 최소 지식 원칙
> - 내부 정보를 가능한 한 숨기고 밀접한 모듈과 상호작용해 결합도를 낮추는 원칙.
> - 래퍼 메소드가 너무 늘어나는 부작용이 있을때 사용한다.
> ### 7.9 알고리즘 교체하기