# 리팩터링

## 2. 리팩터링 원칙
> ### 2.1 리팩터링은 그 과정에서 겉보기 동작 유지가 중요하다.
> ### 2.2 기능 추가와 리팩터링을 명확하게 구분하라
> ### 2.3 YAGNI (You Aren't Going to Need It)
> ### 2.4 리팩터링과 성능
> - 성능에 신경쓰지 않고 보기 좋게 코딩한다
> - 성능 최적화가 필요하면 프로파일링해서 실행 시간이 긴 코드를 특정한다.
> - 그 부분을 개선한다.

## 3. 코드에서 나는 악취
> ### 3.1 기이한 이름
> ### 3.2 중복 코드
> ### 3.3 긴 함수
> ### 3.4 긴 매개변수 목록
> ### 3.5 전역 데이터
> ### 3.6 가변 데이터
> - 정해진 함수를 통해서만 값을 수정할 수 있도록 한다.
> - 용도별로 독립 변수에 저장해 값 갱신이 문제를 일으킬 여지를 없앤다.
> - 변수를 갱신하는 코드들의 유효범위를 제한한다.
> ### 3.7 뒤엉킨 변경
> - 단일 책임 원칙 위반.
> - 한 모듈이 다른 이유들로 인해 여러가지 방식으로 변경되는 경우.
> - 맥락별로 분리해야 한다.
> ### 3.8 산탄총 수술
> - 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우.
> - 함께 변경되는 대상들을 한 모듈에 모아야 한다.
> ### 3.9 기능 편애
> - 어떤 함수가 자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 더 많이 상호작용 하는 경우.
> ### 3.10 데이터 뭉치
> - 데이터 항목 여러 개가 여러 곳에서 뭉쳐 다니는 경우.
> - 레코드 구조가 아닌 클래스로 만들기를 권장한다.
> ### 3.11 기본형 집착
> ### 3.12 반복되는 switch문
> ### 3.13 반복문
> ### 3.14 성의 없는 요소
> ### 3.15 추측성 일반화
> - 미래를 대비해 작성한 코드.
> ### 3.16 임시 필드
> - 특정 상황에서만 값이 설정되는 필드.
> - 코드를 이해하기 어렵다.
> ### 3.17 메세지 체인
> - 클라이언트가 한객체를 통해 다른 객체를 얻은 뒤 또 다른 객체를 요청하는 형식.
> - ex) managerName = aPerson.department.manager.name;
> ### 3.18 중개자
> - 객체의 위임이 지나친 경우. 
> ### 3.19 내부자 거래
> - 모듈 간에 데이터 교환이 많아 결합도가 높아진 경우.
> ### 3.20 거대한 클래스
> ### 3.21 서로 다른 인터페이스의 대안 클래스들
> ### 3.22 데이터 클래스
> - 데이터 필드와 getter/setter 메서드로만 구성된 클래스.
> - 필요한 동작이 엉뚱한 곳에 정의되어 있을 수 있다.
> ### 3.23 상속 포기
> - 자식 클래스에서 부모 클래스의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 경우.
> - 위임으로 바꿔 해결한다.
> ### 3.24 주석

## 6. 기본적인 리팩터링
> ### 6.1 함수 추줄하기
> ### 6.2 함수 인라인하기
> ### 6.3 변수 추출하기
> - 표현식이 복잡할 때 지역 변수를 활용해 표현식을 쪼갠다.
> ### 6.4 변수 인라인하기
> ### 6.5 함수 선언 바꾸기
> ### 6.6 변수 캡슐화하기
> ### 6.7 변수 이름 바꾸기
> ### 6.8 매개변수 객체 만들기
> ### 6.9 여러 함수를 클래스로 묶기
> - 원본 데이터 수정이 있는 경우 사용
> ### 6.10 여러 함수를 변환 함수로 묶기
> - 원본 데이터 수정이 없는 경우 사용
> ### 6.11 단계 쪼개기

## 7. 캡슐화
> ### 7.1 레코드 캡슐화하기
> - 데이터를 쓰는 함수를 만든다.
> - 데이터를 읽는 코드는 독립 함수로 추출한다.
> - 또는 내부 데이터를 복제해서 제공하거나 읽기 전용 프록시를 반환한다.
> ### 7.2 컬렉션 캡슐화하기
> - 원소를 추가/제거하는 함수를 만들고 세터를 제거한다.
> - 게터는 원본 내용을 수정할 수 없도록 읽기 전용 프록시나 복제본을 반환한다.
> ### 7.3 기본형을 객체로 바꾸기
> - 단순한 출력 이상의 기능이 필요해지면 기본형을 객체로 바꾼다.
> ### 7.4 임시 변수를 질의 함수로 바꾸기
> - 어떤 코드의 결과값을 다시 참조할 목적으로 만든 임시 변수를 함수로 만들어 사용한다.
> - 클래스에서 수행할 때 효과가 좋다.
> ### 7.5 클래스 추출하기 
> ### 7.6 클래스 인라인하기
> ### 7.7 위임 숨기기
> ### 7.8 중재자 제거하기
> - 디미터 법칙, 최소 지식 원칙
> - 내부 정보를 가능한 한 숨기고 밀접한 모듈과 상호작용해 결합도를 낮추는 원칙.
> - 래퍼 메소드가 너무 늘어나는 부작용이 있을때 사용한다.
> ### 7.9 알고리즘 교체하기

## 8. 기능 이동
> ### 8.1 함수 옮기기
> ### 8.2 필드 옮기기
> ### 8.3 문장을 함수로 추출하기
> ### 8.4 문장을 호출한 곳으로 옮기기
> ### 8.5 인라인 코드를 함수 호출로 바꾸기
> - 인라인 코드를 대채할 함수가 있을 때 사용한다.
> ### 8.6 문장 슬라이드 하기
> - 요소를 선언하는 곳과 사용하는 곳을 가까이 둔다.
> - 부수효과(Side Effect)
> ### 8.7 반복문 쪼개기
> - 반복문을 쪼갠 후 함수로 추출하는 것 까지 고려한다.
> - 성능은 리팩토링 후 병목이 생기면 수행한다.
> ### 8.8 반복문을 파이프라인으로 바꾸기
> ### 8.9 죽은 코드 제거하기

## 9. 데이터 조직화
> ### 9.1 변수 쪼개기
> - 변수에 대입이 두 번 이상 수행되면 여러 가지 역할을 수행한다는 신호다.
> - 역할이 둘 이상인 변수는 쪼개고 가능한 불변으로 관리한다. 
> ### 9.2 필드 이름 바꾸기
> ### 9.3 파생 변수를 질의 함수로 바꾸기
> - 파생 변수는 다른 변수를 통해 값이 유도되는 변수이다.
> - 가변 데이터의 유효 범위는 가능한 좁힌다.
> - 값에 영향을 주는 요소가 둘 이상이면 변수 쪼개기를 한다.
> ### 9.4 참조를 값으로 바꾸기
> - 값 객체는 불변이다.
> - 수정할 때 새로운 속성을 담은 객체로 기존 객체를 통째로 대체한다.
> - 서로 간의 참조를 관리하지 않아도 된다.
> - 값 객체의 속성값으로 동등성을 비교하는 메서드를 만들어야 한다.
> ### 9.5 값을 참조로 바꾸기
> - 객체의 속성값이 수정되면 같은 객체를 공유하는 다른 곳에서도 적용되어야 한다.
> - 클라이언트들의 객체 접근을 관리하는 repository 를 만들어야 한다.
> ### 9.6 매직 리터럴 바꾸기

## 10. 조건부 로직 간소화
> ### 10.1 조건문 분해하기
> ### 10.2 조건식 통합하기
> ### 10.3 중첩 조건문을 보호 구문으로 바꾸기
> - 한쪽만 정상인 조건문에서 비정상 조건을 if 에서 검사한다.
> - 비정상 조건이면 함수를 리턴해 빠져나온다.
> ### 10.4 조건부 로직을 다형성으로 바꾸기
> - 타입을 기준으로 분기하는 switch 문이 사용되면 다형성을 고려한다.
> - 적합한 인스턴스를 만들어 반환하는 팩터리 함수도 함께 만든다.
> ### 10.5 특이 케이스 추가하기
> - 데이터 구조에서 특정 값을 확인하고 같은 동작을 수행하는 코드가 반복되면 한 곳으로 모으는게 효율적이다.
> - 특이 케이스 객체를 만들어 한 곳으로 모은다.
> - 데이터 구조를 읽기만 하고 수정하지 않으면 리터럴 객체를 사용해도 된다. 
> - 리터럴 객체는 불변으로 만들어야 한다.
> - 변환 함수를 통해서도 한 곳으로 모을 수 있다.
> ### 10.6 어설션 추가하기
> - 어설션은 어떤 상태를 가정한 채 코드가 실행되는지 다른 개발자에게 알려주는 좋은 소통 도구이다.
> ### 10.7 제어 플래그를 탈출문으로 바꾸기
> - 제어 플래그는 코드의 동작을 변경하는데 사용되는 변수이다.
> - 어딘가에서 값을 계산해 제어 플래그를 설정하고 다른 어딘가의 조건문에서 검사하는 형태로 사용된다.
> - 주로 반복문 안에서 사용되며 break, continue, return 을 제대로 사용하지 못해 발생한다.