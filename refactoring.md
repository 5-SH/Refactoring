# 리팩터링

## 2. 리팩터링 원칙
> ### 2.1 리팩터링은 그 과정에서 겉보기 동작 유지가 중요하다.
> ### 2.2 기능 추가와 리팩터링을 명확하게 구분하라
> ### 2.3 YAGNI (You Aren't Going to Need It)
> ### 2.4 리팩터링과 성능
> - 성능에 신경쓰지 않고 보기 좋게 코딩한다
> - 성능 최적화가 필요하면 프로파일링해서 실행 시간이 긴 코드를 특정한다.
> - 그 부분을 개선한다.

## 3. 코드에서 나는 악취
> ### 3.1 기이한 이름
> ### 3.2 중복 코드
> ### 3.3 긴 함수
> ### 3.4 긴 매개변수 목록
> ### 3.5 전역 데이터
> ### 3.6 가변 데이터
> - 정해진 함수를 통해서만 값을 수정할 수 있도록 한다.
> - 용도별로 독립 변수에 저장해 값 갱신이 문제를 일으킬 여지를 없앤다.
> - 변수를 갱신하는 코드들의 유효범위를 제한한다.
> ### 3.7 뒤엉킨 변경
> - 단일 책임 원칙 위반.
> - 한 모듈이 다른 이유들로 인해 여러가지 방식으로 변경되는 경우.
> - 맥락별로 분리해야 한다.
> ### 3.8 산탄총 수술
> - 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많은 경우.
> - 함께 변경되는 대상들을 한 모듈에 모아야 한다.
> ### 3.9 기능 편애
> - 어떤 함수가 자신이 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 더 많이 상호작용 하는 경우.
> ### 3.10 데이터 뭉치
> - 데이터 항목 여러 개가 여러 곳에서 뭉쳐 다니는 경우.
> - 레코드 구조가 아닌 클래스로 만들기를 권장한다.
> ### 3.11 기본형 집착
> ### 3.12 반복되는 switch문
> ### 3.13 반복문
> ### 3.14 성의 없는 요소
> ### 3.15 추측성 일반화
> - 미래를 대비해 작성한 코드.
> ### 3.16 임시 필드
> - 특정 상황에서만 값이 설정되는 필드.
> - 코드를 이해하기 어렵다.
> ### 3.17 메세지 체인
> - 클라이언트가 한객체를 통해 다른 객체를 얻은 뒤 또 다른 객체를 요청하는 형식.
> - ex) managerName = aPerson.department.manager.name;
> ### 3.18 중개자
> - 객체의 위임이 지나친 경우. 
> ### 3.19 내부자 거래
> - 모듈 간에 데이터 교환이 많아 결합도가 높아진 경우.
> ### 3.20 거대한 클래스
> ### 3.21 서로 다른 인터페이스의 대안 클래스들
> ### 3.22 데이터 클래스
> - 데이터 필드와 getter/setter 메서드로만 구성된 클래스.
> - 필요한 동작이 엉뚱한 곳에 정의되어 있을 수 있다.
> ### 3.23 상속 포기
> - 자식 클래스에서 부모 클래스의 동작은 필요로 하지만 인터페이스는 따르고 싶지 않을 경우.
> - 위임으로 바꿔 해결한다.
> ### 3.24 주석

## 6. 기본적인 리팩터링
> ### 6.1 함수 추줄하기
> ### 6.2 함수 인라인하기
> ### 6.3 변수 추출하기
> ### 6.4 변수 인라인하기
> ### 6.5 함수 선언 바꾸기
> ### 6.6 변수 캡슐화하기
> ### 6.7 변수 이름 바꾸기
> ### 6.8 매개변수 객체 만들기
> ### 6.9 여러 함수를 클래스로 묶기
> - 원본 데이터 수정이 있는 경우 사용
> ### 6.10 여러 함수를 변환 함수로 묶기
> - 원본 데이터 수정이 없는 경우 사용
> ### 6.11 단계 쪼개기

## 7. 캡슐화
> ### 7.1 레코드 캡슐화하기
> - 데이터를 쓰는 함수를 만든다.
> - 데이터를 읽는 코드는 독립 함수로 추출한다.
> - 또는 내부 데이터를 복제해서 제공하거나 읽기 전용 프록시를 반환한다.
> ### 7.2 컬렉션 캡슐화하기
> - 원소를 추가/제거하는 함수를 만들고 세터를 제거한다.
> - 게터는 원본 내용을 수정할 수 없도록 읽기 전용 프록시나 복제본을 반환한다.
> ### 7.3 기본형을 객체로 바꾸기
> - 단순한 출력 이상의 기능이 필요해지면 기본형을 객체로 바꾼다.
> ### 7.4 임시 변수를 질의 함수로 바꾸기
> - 클래스에서 수행할 때 효과가 좋다.
> ### 7.5 클래스 추출하기 
> ### 7.6 클래스 인라인하기
> ### 7.7 위임 숨기기
> ### 7.8 중재자 제거하기
> - 디미터 법칙, 최소 지식 원칙
> - 내부 정보를 가능한 한 숨기고 밀접한 모듈과 상호작용해 결합도를 낮추는 원칙.
> - 래퍼 메소드가 너무 늘어나는 부작용이 있을때 사용한다.
> ### 7.9 알고리즘 교체하기

## 8. 기능 이동
> ### 8.1 함수 옮기기
> ### 8.2 필드 옮기기
> ### 8.3 문장을 함수로 추출하기
> ### 8.4 문장을 호출한 곳으로 옮기기
> ### 8.5 인라인 코드를 함수 호출로 바꾸기
> - 인라인 코드를 대채할 함수가 있을 때 사용한다.
> ### 8.6 문장 슬라이드 하기
> - 요소를 선언하는 곳과 사용하는 곳을 가까이 둔다.
> - 부수효과(Side Effect)
> ### 8.7 반복문 쪼개기
> - 반복문을 쪼갠 후 함수로 추출하는 것 까지 고려한다.
> - 성능은 리팩토링 후 병목이 생기면 수행한다.
> ### 8.8 반복문을 파이프라인으로 바꾸기
> ### 8.9 죽은 코드 제거하기